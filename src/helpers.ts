import { Page, expect } from 'playwright/test';

/** Remove ou aguarda o desaparecimento de overlays que bloqueiam cliques */
export async function waitForOverlaysToDisappear(page: Page) {
  console.log('üîç Verificando overlays que podem bloquear cliques...');
  
  // Primeiro, tenta fechar modais/overlays clicando no backdrop ou ESC
  const overlaySelectors = [
    '.cdk-overlay-backdrop',
    '.cdk-overlay-transparent-backdrop',
    '.mat-dialog-container'
  ];
  
  for (const selector of overlaySelectors) {
    try {
      const overlay = page.locator(selector);
      const count = await overlay.count();
      if (count > 0) {
        console.log(`üö´ Encontrado overlay ${selector} (${count} elementos), tentando fechar...`);
        
        // Tenta clicar no backdrop para fechar
        if (selector.includes('backdrop')) {
          try {
            await overlay.first().click({ force: true, timeout: 2000 });
            console.log(`‚úÖ Clicou no backdrop ${selector}`);
          } catch (e) {
            console.log(`‚ö†Ô∏è Erro ao clicar no backdrop: ${e}`);
          }
        }
        
        // Tenta ESC para fechar modais
        await page.keyboard.press('Escape');
        await page.waitForTimeout(500);
        
        // Verifica se ainda existe
        const stillExists = await overlay.count();
        if (stillExists > 0) {
          console.log(`‚ö†Ô∏è Overlay ${selector} ainda existe ap√≥s tentativa de fechamento`);
        } else {
          console.log(`‚úÖ Overlay ${selector} foi fechado`);
        }
      }
    } catch (e) {
      console.log(`Erro ao processar overlay ${selector}: ${e}`);
    }
  }
  
  // Aguarda um pouco extra para garantir que a p√°gina est√° est√°vel
  await page.waitForTimeout(1000);
  console.log('‚úÖ Overlays processados');
}

/** Aguarda e clica no primeiro bot√£o com "editar"/√≠cone de l√°pis */
export async function clickFirstEditButton(page: Page) {
  console.log('üîç Procurando bot√£o de editar...');
  
  // Aguarda um pouco para a p√°gina carregar ap√≥s preencher CPF
  await page.waitForTimeout(2000);
  
  // Tenta varia√ß√µes comuns de r√≥tulo/√≠cone
  const candidates = [
    page.getByRole('button', { name: /editar|l√°pis|edit/i }),
    page.locator('button[aria-label*="Editar" i]'),
    page.locator('button[title*="Editar" i]'),
    page.locator('i[class*="pencil"], i[title*="Editar" i]').locator('xpath=ancestor::button[1]'),
    page.locator('button:has(i[class*="pencil"]), button:has(i[class*="edit"]), button:has(i[class*="fa-edit"])'),
    page.locator('a[title*="Editar" i], a[aria-label*="Editar" i]'),
    page.locator('button:has-text("Editar"), a:has-text("Editar")'),
    page.locator('[data-action*="edit" i], [onclick*="edit" i]'),
    page.locator('button.btn:has(i), a.btn:has(i)') // Bot√µes gen√©ricos com √≠cones
  ];
  
  for (let i = 0; i < candidates.length; i++) {
    const c = candidates[i];
    const count = await c.count();
    console.log(`Candidato ${i + 1}: ${count} elementos encontrados`);
    if (count > 0) {
      console.log(`‚úÖ Clicando no candidato ${i + 1}`);
      await c.first().click();
      return;
    }
  }
  
  // Debug: vamos ver todos os bot√µes dispon√≠veis
  console.log('üîç Debug: Listando todos os bot√µes dispon√≠veis na p√°gina...');
  const allButtons = await page.locator('button, a[role="button"], input[type="button"], input[type="submit"]').all();
  for (let i = 0; i < Math.min(allButtons.length, 20); i++) {
    const btn = allButtons[i];
    const text = await btn.textContent();
    const title = await btn.getAttribute('title');
    const ariaLabel = await btn.getAttribute('aria-label');
    console.log(`Bot√£o ${i + 1}: texto="${text}" title="${title}" aria-label="${ariaLabel}"`);
  }
  
  throw new Error('Bot√£o de editar (l√°pis) n√£o foi encontrado ap√≥s o preenchimento do CPF.');
}

/** Vai para a aba "Servidor" */
export async function goToServidorTab(page: Page) {
  console.log('üîç Procurando aba "Servidor"...');
  
  // Aguardar um pouco mais para as abas carregarem
  await page.waitForTimeout(2000);
  
  // Tentar diferentes seletores para a aba Servidor
  const tabCandidates = [
    page.getByRole('tab', { name: /servidor/i }),
    page.locator('[role="tab"]:has-text("Servidor")'),
    page.locator('mat-tab-label:has-text("Servidor")'),
    page.locator('.mat-tab-label:has-text("Servidor")'),
    page.locator('div[role="tab"]:has-text("Servidor")'),
    page.locator('button[role="tab"]:has-text("Servidor")'),
    page.locator('[aria-label*="Servidor" i][role="tab"]'),
    page.locator('a:has-text("Servidor")'),
    page.locator('*:has-text("Servidor")[role="tab"]'),
    page.locator('mat-tab-label').filter({ hasText: /servidor/i }),
    page.locator('.mat-tab-label').filter({ hasText: /servidor/i })
  ];
  
  let tabFound = false;
  
  // Verificar se a p√°gina ainda est√° conectada
  try {
    await page.waitForTimeout(100); // Teste r√°pido de conex√£o
  } catch (error) {
    throw new Error('‚ùå P√°gina foi fechada ou conex√£o perdida. Certifique-se de que o Chrome est√° aberto e na p√°gina correta.');
  }
  
  // Tentar m√∫ltiplas vezes com intervalos
  for (let attempt = 1; attempt <= 3; attempt++) {
    console.log(`üîÑ Tentativa ${attempt} de encontrar aba Servidor...`);
    
    for (let i = 0; i < tabCandidates.length; i++) {
      const tab = tabCandidates[i];
      let count;
      try {
        count = await tab.count();
      } catch (error) {
        throw new Error('‚ùå P√°gina foi fechada ou conex√£o perdida durante a busca. Certifique-se de que o Chrome est√° aberto e na p√°gina correta.');
      }
      console.log(`Candidato ${i + 1} (aba Servidor): ${count} elementos encontrados`);
      if (count > 0) {
        try {
          await tab.first().waitFor({ state: 'visible', timeout: 8000 });
          console.log(`‚úÖ Clicando na aba Servidor (candidato ${i + 1})...`);
          await tab.first().click();
          tabFound = true;
          break;
        } catch (e) {
           console.log(`Candidato ${i + 1} n√£o funcionou:`, e instanceof Error ? e.message : String(e));
        }
      }
    }
    
    if (tabFound) break;
    
    // Se n√£o encontrou, aguarda mais um pouco antes da pr√≥xima tentativa
    if (attempt < 3) {
      console.log('‚è≥ Aguardando mais tempo para abas carregarem...');
      await page.waitForTimeout(3000);
    }
  }
  
  if (!tabFound) {
    // Debug: listar todas as abas dispon√≠veis
    console.log('üîç Debug: Listando abas dispon√≠veis...');
    const allTabs = await page.locator('[role="tab"], mat-tab-label, .mat-tab-label, *[role="tab"]').all();
    for (let i = 0; i < Math.min(allTabs.length, 15); i++) {
      const tab = allTabs[i];
      const text = await tab.textContent();
      const ariaLabel = await tab.getAttribute('aria-label');
      const className = await tab.getAttribute('class');
      console.log(`Aba ${i + 1}: texto="${text}" aria-label="${ariaLabel}" class="${className}"`);
    }
    
    // Debug: listar todos os elementos que cont√™m "Servidor"
    console.log('üîç Debug: Elementos que cont√™m "Servidor"...');
    const servidorElements = await page.locator('*:has-text("Servidor")').all();
    for (let i = 0; i < Math.min(servidorElements.length, 20); i++) {
      const element = servidorElements[i];
      const tagName = await element.evaluate(el => el.tagName);
      const text = await element.textContent();
      const role = await element.getAttribute('role');
      console.log(`Elemento ${i + 1}: <${tagName}> texto="${text}" role="${role}"`);
    }
    
    throw new Error('Aba "Servidor" n√£o foi encontrada ap√≥s m√∫ltiplas tentativas');
  }
  
  console.log('‚úÖ Aba Servidor selecionada com sucesso');
}

/** Clica em "Adicionar localiza√ß√£o/visibilidade" */
export async function clickAddLocalizacao(page: Page) {
  console.log('üîç Procurando bot√£o "Adicionar Localiza√ß√£o"...');
  
  // Primeiro, aguarda overlays desaparecerem
  await waitForOverlaysToDisappear(page);
  
  // Tenta diferentes varia√ß√µes do bot√£o
  const candidates = [
    page.getByRole('button', { name: /adicionar.*(localiza|visibili)/i }),
    page.locator('button:has-text("Adicionar"):has-text("Localiza√ß√£o")'),
    page.locator('button:has-text("Adicionar"):has-text("Visibilidade")'),
    page.locator('button[title*="Adicionar" i][title*="Localiza√ß√£o" i]'),
    page.locator('button[aria-label*="Adicionar" i][aria-label*="Localiza√ß√£o" i]'),
    page.locator('button:has-text("Adicionar Localiza√ß√£o")'),
    page.locator('button:has-text("Adicionar Visibilidade")')
  ];
  
  for (let i = 0; i < candidates.length; i++) {
    const candidate = candidates[i];
    const count = await candidate.count();
    console.log(`Candidato ${i + 1} (Adicionar): ${count} elementos encontrados`);
    if (count > 0) {
      console.log(`‚úÖ Clicando no candidato ${i + 1} para Adicionar`);
      await expect(candidate.first()).toBeVisible({ timeout: 10000 });
      
      // Tenta clique normal primeiro, depois force click se necess√°rio
      try {
        await candidate.first().click({ timeout: 5000 });
      } catch (e) {
        console.log('‚ö†Ô∏è Clique normal falhou, tentando force click...');
        await candidate.first().click({ force: true });
      }
      return;
    }
  }
  
  // Debug: listar todos os bot√µes que cont√™m "Adicionar"
  console.log('üîç Debug: Listando bot√µes com "Adicionar"...');
  const addButtons = await page.locator('button:has-text("Adicionar"), button[title*="Adicionar" i], button[aria-label*="Adicionar" i]').all();
  for (let i = 0; i < Math.min(addButtons.length, 5); i++) {
    const btn = addButtons[i];
    const text = await btn.textContent();
    const title = await btn.getAttribute('title');
    const ariaLabel = await btn.getAttribute('aria-label');
    console.log(`Bot√£o Adicionar ${i + 1}: texto="${text}" title="${title}" aria-label="${ariaLabel}"`);
  }
  
  throw new Error('Bot√£o "Adicionar Localiza√ß√£o/Visibilidade" n√£o foi encontrado.');
}

/** Normaliza nome do √≥rg√£o julgador para o formato padr√£o do PJe */
export function normalizeOrgaoName(orgaoName: string): string {
  let normalized = orgaoName.trim();
  
  // Mapeamento de abrevia√ß√µes para formato completo
  const abbreviations: Record<string, string> = {
    'VT': 'Vara do Trabalho',
    'VCT': 'Vara C√≠vel do Trabalho',
    'JT': 'Junta de Trabalho',
    'TRT': 'Tribunal Regional do Trabalho'
  };
  
  // Expandir abrevia√ß√µes
  for (const [abbrev, full] of Object.entries(abbreviations)) {
    const regex = new RegExp(`\\b${abbrev}\\b`, 'gi');
    normalized = normalized.replace(regex, full);
  }
  
  // Normalizar formato de numera√ß√£o ordinal
  normalized = normalized.replace(/^(\d+)[¬™¬∫¬∞]?\s*/, '$1¬™ ');
  
  // Garantir que "Vara do Trabalho" esteja no formato correto
  normalized = normalized.replace(/vara\s+do?\s+trabalho/gi, 'Vara do Trabalho');
  
  // Normalizar nomes de cidades (MAI√öSCULA -> Title Case)
  normalized = normalized.replace(/\b[A-Z√Å√ä√ç√ì√ö√á√É√ï]{2,}\b/g, (match) => {
    // Exce√ß√µes que devem permanecer em mai√∫scula
    const exceptions = ['SP', 'RJ', 'MG', 'RS', 'PR', 'SC', 'GO', 'MT', 'MS', 'BA', 'PE', 'CE', 'PA', 'AM', 'RO', 'AC', 'RR', 'AP', 'TO', 'MA', 'PI', 'AL', 'SE', 'PB', 'RN', 'ES', 'DF'];
    if (exceptions.includes(match)) return match;
    
    return match.charAt(0) + match.slice(1).toLowerCase();
  });
  
  // üîß CORRE√á√ÉO: Padronizar preposi√ß√µes - garantir que tenha 'de' ap√≥s 'Vara do Trabalho' APENAS se n√£o existir
  // Evitar criar "de de" verificando se j√° existe "de" na posi√ß√£o
  normalized = normalized.replace(/(\d+[¬™¬∫¬∞]?\s+)?Vara do Trabalho\s+(?!de\s+)([A-Z√Å√ä√ç√ì√ö√á√É√ï])/gi, '$1Vara do Trabalho de $2');
  
  // Corrigir espa√ßamentos m√∫ltiplos
  normalized = normalized.replace(/\s+/g, ' ').trim();
  
  // Aplicar Title Case geral
  normalized = toTitleCase(normalized);
  
  return normalized;
}

/** Expande abrevia√ß√µes comuns de √≥rg√£os julgadores e gera varia√ß√µes de mai√∫sculas/min√∫sculas */
function expandAbbreviations(orgaoName: string): string[] {
  const prioritizedVariations: string[] = [];
  const variations = new Set<string>();
  
  // üîß CORRE√á√ÉO: Primeiro, limpar e normalizar o nome de entrada
  const cleanedName = orgaoName.trim().replace(/\s+/g, ' ');
  const normalizedName = normalizeOrgaoName(cleanedName);
  
  // üéØ PRIORIDADE 1: Nome normalizado exato (maior prioridade - mais confi√°vel)
  prioritizedVariations.push(normalizedName);
  variations.add(normalizedName);
  
  // üéØ PRIORIDADE 2: Nome original exato
  if (cleanedName !== normalizedName) {
    prioritizedVariations.push(cleanedName);
    variations.add(cleanedName);
  }
  
  // üéØ PRIORIDADE 3: Varia√ß√µes de case do nome original
  const originalCaseVariations = [
    toTitleCase(cleanedName),
    cleanedName.toLowerCase(),
    cleanedName.toUpperCase()
  ];
  
  for (const variation of originalCaseVariations) {
    if (!variations.has(variation)) {
      prioritizedVariations.push(variation);
      variations.add(variation);
    }
  }
  
  // üéØ PRIORIDADE 4: Varia√ß√µes de case do nome normalizado
  const normalizedCaseVariations = [
    toTitleCase(normalizedName),
    normalizedName.toLowerCase(),
    normalizedName.toUpperCase()
  ];
  
  for (const variation of normalizedCaseVariations) {
    if (!variations.has(variation)) {
      prioritizedVariations.push(variation);
      variations.add(variation);
    }
  }
  
  // üîß CORRE√á√ÉO: Expandir abrevia√ß√µes de forma mais controlada
  const abbreviations = {
    'VT': 'Vara do Trabalho',
    'VCT': 'Vara C√≠vel do Trabalho', 
    'JT': 'Junta de Trabalho',
    'TRT': 'Tribunal Regional do Trabalho'
  };
  
  const namesToProcess = [cleanedName, normalizedName];
  
  for (const nameToProcess of namesToProcess) {
    for (const [abbrev, full] of Object.entries(abbreviations)) {
      const abbrevRegex = new RegExp(`\\b${abbrev}\\b`, 'gi');
      
      if (abbrevRegex.test(nameToProcess)) {
        const expanded = nameToProcess.replace(abbrevRegex, full);
        
        // üîß CORRE√á√ÉO: Limpar espa√ßos duplos que podem ser criados
        const cleanExpanded = expanded.replace(/\s+/g, ' ').trim();
        
        if (!variations.has(cleanExpanded)) {
          prioritizedVariations.push(cleanExpanded);
          variations.add(cleanExpanded);
          
          // Adicionar varia√ß√µes de case do nome expandido
          const expandedCaseVariations = [
            toTitleCase(cleanExpanded),
            cleanExpanded.toLowerCase(),
            cleanExpanded.toUpperCase()
          ];
          
          for (const caseVar of expandedCaseVariations) {
            if (!variations.has(caseVar)) {
              prioritizedVariations.push(caseVar);
              variations.add(caseVar);
            }
          }
        }
      }
    }
  }
  
  // üîß CORRE√á√ÉO: Varia√ß√µes com preposi√ß√µes de forma mais controlada
  const currentVariations = [...prioritizedVariations];
  
  for (const variation of currentVariations) {
    // üîß CORRE√á√ÉO: Evitar criar "de de" ou outras duplica√ß√µes
    
    // Adicionar "de" apenas se n√£o existir e se fizer sentido
    if (/(\d+[¬™¬∫¬∞]?\s+)?Vara do Trabalho\s+([A-Z√Å√ä√ç√ì√ö√á√É√ï][a-z√°√™√≠√≥√∫√ß√£√µ]+)$/i.test(variation) && 
        !variation.toLowerCase().includes(' de ')) {
      const withDe = variation.replace(/(Vara do Trabalho)\s+([A-Z√Å√ä√ç√ì√ö√á√É√ï])/i, '$1 de $2');
      
      if (!variations.has(withDe)) {
        prioritizedVariations.push(withDe);
        variations.add(withDe);
        
        // Varia√ß√µes de case
        const withDeCaseVariations = [
          toTitleCase(withDe),
          withDe.toLowerCase(),
          withDe.toUpperCase()
        ];
        
        for (const caseVar of withDeCaseVariations) {
          if (!variations.has(caseVar)) {
            prioritizedVariations.push(caseVar);
            variations.add(caseVar);
          }
        }
      }
    }
    
    // Remover "de" apenas se existir e criar uma varia√ß√£o v√°lida
    if (variation.toLowerCase().includes(' de ')) {
      const withoutDe = variation.replace(/(Vara do Trabalho)\s+de\s+/i, '$1 ');
      
      if (withoutDe !== variation && !variations.has(withoutDe)) {
        prioritizedVariations.push(withoutDe);
        variations.add(withoutDe);
        
        // Varia√ß√µes de case
        const withoutDeCaseVariations = [
          toTitleCase(withoutDe),
          withoutDe.toLowerCase(),
          withoutDe.toUpperCase()
        ];
        
        for (const caseVar of withoutDeCaseVariations) {
          if (!variations.has(caseVar)) {
            prioritizedVariations.push(caseVar);
            variations.add(caseVar);
          }
        }
      }
    }
  }
  
  // üîß CORRE√á√ÉO: Filtrar varia√ß√µes problem√°ticas e duplicadas
  const finalVariations = prioritizedVariations.filter(variation => {
    const cleaned = variation.trim().replace(/\s+/g, ' ');
    
    // Filtrar varia√ß√µes com problemas √≥bvios
    if (cleaned.includes('  ') || // espa√ßos duplos
        cleaned.includes(' de de ') || // "de de"
        cleaned.includes(' da da ') || // "da da"
        cleaned.includes(' do do ') || // "do do"
        cleaned.includes(' De De ') || // "De De" (mai√∫scula)
        cleaned.includes(' Da Da ') || // "Da Da" (mai√∫scula)
        cleaned.includes(' Do Do ') || // "Do Do" (mai√∫scula)
        cleaned.length < 3) { // muito curto
      return false;
    }
    
    return true;
  });
  
  // üéØ RESULTADO: Retornar varia√ß√µes ordenadas por prioridade (mais espec√≠ficas primeiro)
  return finalVariations;
}

/** Converte string para Title Case (Primeira Letra Mai√∫scula) */
function toTitleCase(str: string): string {
  return str.replace(/\w\S*/g, (txt) => 
    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
  );
}

/** Seleciona √ìrg√£o Julgador no di√°logo de inclus√£o */
export async function selectOrgaoJulgador(page: Page, ojName: string, perfil: string) {
  console.log(`üîç Procurando campo de √ìrg√£o Julgador para: ${ojName}`);
  
  // Gerar varia√ß√µes do nome do √≥rg√£o (ordenadas por prioridade)
  const nameVariations = expandAbbreviations(ojName);
  console.log(`üìù Varia√ß√µes a tentar: ${nameVariations.join(', ')}`);
  
  // Campo do OJ (combobox/autocomplete) - mais espec√≠fico para evitar conflitos
  // Procura especificamente por mat-select que n√£o esteja desabilitado e tenha o placeholder correto
  const combo = page.locator('mat-select[placeholder*="√ìrg√£o Julgador" i]:not([aria-disabled="true"]):not(.mat-select-disabled)').first();
  
  console.log('üîç Aguardando campo de √ìrg√£o Julgador ficar vis√≠vel...');
  await expect(combo).toBeVisible({ timeout: 10000 });
  
  console.log('üñ±Ô∏è Clicando no campo de √ìrg√£o Julgador...');
  await combo.click();
  
  // Tentar encontrar op√ß√£o com cada varia√ß√£o do nome
  let optionFound = false;
  let selectedVariation = '';
  
  for (const variation of nameVariations) {
    console.log(`‚è≥ Tentando buscar op√ß√£o para: ${variation}`);
    
    try {
      // Estrat√©gia 1: Tentar digitar para filtrar (para campos de autocomplete)
      const inputField = page.locator('input[placeholder*="√ìrg√£o Julgador" i], mat-select input, .mat-select-trigger input');
      if (await inputField.count() > 0) {
        console.log('üìù Tentando digitar no campo de input para filtrar...');
        await inputField.first().clear();
        await inputField.first().fill(variation);
        await page.waitForTimeout(1500); // Aguarda filtro ser aplicado
      }
      
      // Aguarda sugest√£o aparecer
      await page.waitForTimeout(1000);
      
      // üîß CORRE√á√ÉO: Estrat√©gias de busca priorizando matches exatos
      const searchStrategies = [
        // 1. Busca EXATA case-insensitive (PRIORIDADE M√ÅXIMA)
        page.getByRole('option', { name: new RegExp(`^${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') }),
        // 2. Busca por mat-option com texto EXATO
        page.locator(`mat-option`).filter({ hasText: new RegExp(`^${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') }),
        page.locator(`[role="option"]`).filter({ hasText: new RegExp(`^${variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`, 'i') }),
        // 3. Busca contendo o texto (mas verificando se √© match exato)
        page.getByRole('option', { name: new RegExp(variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i') }),
        // 4. Busca por mat-option com texto contendo
        page.locator(`mat-option:has-text("${variation}")`),
        page.locator(`[role="option"]:has-text("${variation}")`)
        // üö´ REMOVIDO: Busca por cidade apenas (causa o problema de sele√ß√£o incorreta)
      ];
      
      // üéØ ESTRAT√âGIA MELHORADA: Coletar todas as op√ß√µes e priorizar matches exatos
      const options = page.locator('mat-option:visible, .mat-option:visible');
      const optionCount = await options.count();
      
      if (optionCount > 0) {
        console.log(`üìã Encontradas ${optionCount} op√ß√µes dispon√≠veis`);
        
        // üîß CORRE√á√ÉO: Coletar todas as op√ß√µes e seus matches primeiro
        const optionMatches: Array<{option: any, text: string, matchType: 'exact' | 'partial' | 'parts', score: number}> = [];
        
        for (let i = 0; i < optionCount; i++) {
          const option = options.nth(i);
          const optionText = await option.textContent();
          
          if (optionText) {
            const normalizedOptionText = optionText.trim().toLowerCase();
            const normalizedVariation = variation.toLowerCase();
            
            // üéØ PRIORIDADE 1: Match exato
            if (normalizedOptionText === normalizedVariation) {
              optionMatches.push({
                option,
                text: optionText,
                matchType: 'exact',
                score: 100
              });
            }
            // üéØ PRIORIDADE 2: Match parcial que cont√©m a varia√ß√£o completa
            else if (normalizedOptionText.includes(normalizedVariation)) {
              // üîß CORRE√á√ÉO: Verificar se √© um match espec√≠fico (n√£o gen√©rico)
              const variationHasNumber = /\d+[¬™¬∫¬∞]/.test(variation);
              const optionHasNumber = /\d+[¬™¬∫¬∞]/.test(optionText);
              
              // Se a varia√ß√£o tem n√∫mero, a op√ß√£o tamb√©m deve ter o mesmo n√∫mero
              if (variationHasNumber && optionHasNumber) {
                const variationNumber = variation.match(/\d+/)?.[0];
                const optionNumber = optionText.match(/\d+/)?.[0];
                
                if (variationNumber === optionNumber) {
                  optionMatches.push({
                    option,
                    text: optionText,
                    matchType: 'partial',
                    score: 90
                  });
                }
              }
              // Se n√£o tem n√∫mero, aceitar match parcial
              else if (!variationHasNumber) {
                optionMatches.push({
                  option,
                  text: optionText,
                  matchType: 'partial',
                  score: 80
                });
              }
            }
            // üéØ PRIORIDADE 3: Match por partes (mais restritivo)
            else {
              const variationParts = normalizedVariation.split(' ').filter(part => part.length > 2);
              const optionParts = normalizedOptionText.split(' ').filter(part => part.length > 2);
              
              const matchingParts = variationParts.filter(part => 
                optionParts.some(optPart => optPart.includes(part) || part.includes(optPart))
              );
              
              // üîß CORRE√á√ÉO: Exigir match de pelo menos 80% das partes E verificar n√∫meros
              const requiredMatches = Math.ceil(variationParts.length * 0.8);
              
              if (matchingParts.length >= requiredMatches && matchingParts.length >= 3) {
                // Verificar consist√™ncia de n√∫meros
                const variationHasNumber = /\d+[¬™¬∫¬∞]/.test(variation);
                const optionHasNumber = /\d+[¬™¬∫¬∞]/.test(optionText);
                
                if (variationHasNumber && optionHasNumber) {
                  const variationNumber = variation.match(/\d+/)?.[0];
                  const optionNumber = optionText.match(/\d+/)?.[0];
                  
                  if (variationNumber === optionNumber) {
                    optionMatches.push({
                      option,
                      text: optionText,
                      matchType: 'parts',
                      score: 70
                    });
                  }
                } else if (!variationHasNumber) {
                  optionMatches.push({
                    option,
                    text: optionText,
                    matchType: 'parts',
                    score: 60
                  });
                }
              }
            }
          }
        }
        
        // üéØ SELE√á√ÉO: Escolher o melhor match (maior score)
        if (optionMatches.length > 0) {
          // Ordenar por score (maior primeiro)
          optionMatches.sort((a, b) => b.score - a.score);
          
          const bestMatch = optionMatches[0];
          console.log(`‚úÖ Melhor match encontrado (${bestMatch.matchType}, score: ${bestMatch.score}): ${bestMatch.text}`);
          
          await bestMatch.option.click();
          optionFound = true;
          selectedVariation = variation;
        }
      }
      
      if (optionFound) break;
      
      console.log(`‚ùå Op√ß√£o n√£o encontrada para: ${variation}`);
    } catch (error) {
      console.log(`‚ùå Erro ao buscar ${variation}:`, error);
    }
  }
  
  if (!optionFound) {
    // Debug: listar op√ß√µes dispon√≠veis
    console.log('üîç Debug: Listando op√ß√µes dispon√≠veis...');
    try {
      const allOptions = await page.locator('mat-option, [role="option"]').all();
      for (let i = 0; i < Math.min(allOptions.length, 20); i++) {
        const option = allOptions[i];
        const text = await option.textContent();
        console.log(`Op√ß√£o ${i + 1}: "${text}"`);
      }
    } catch (debugError) {
      console.log('Erro ao listar op√ß√µes:', debugError);
    }
    
    throw new Error(`√ìrg√£o Julgador n√£o encontrado. Tentativas: ${nameVariations.join(', ')}`);
  }
  
  console.log(`‚úÖ √ìrg√£o selecionado com sucesso: ${selectedVariation}`);

  // Aguarda um pouco para o campo de perfil aparecer
  await page.waitForTimeout(1000);

  // Seleciona o papel configurado
  console.log(`üë§ Procurando campo de Papel para selecionar: ${perfil}...`);
  await page.waitForTimeout(2000); // Aguarda campos carregarem
  
  const papelCandidates = [
    page.locator('mat-select[placeholder*="Papel" i]:not([aria-disabled="true"]):not(.mat-select-disabled)'),
    page.locator('select[name*="papel" i]'),
    page.locator('mat-select:has-text("Papel")'),
    page.locator('mat-select').nth(1), // Segundo mat-select no modal
    page.locator('mat-select[formcontrolname*="papel" i]'),
    page.locator('mat-select').filter({ hasText: /papel/i }),
    page.locator('mat-select').nth(2) // Terceiro mat-select (pode ser o papel)
  ];

  let papelSelected = false;
  for (let i = 0; i < papelCandidates.length; i++) {
    const papelCombo = papelCandidates[i];
    if (await papelCombo.count() > 0) {
      try {
        await papelCombo.first().waitFor({ state: 'visible', timeout: 3000 });
        console.log(`üñ±Ô∏è Clicando no campo de Papel (candidato ${i + 1})...`);
        await papelCombo.first().click();
        
        // Aguarda op√ß√µes aparecerem
        await page.waitForTimeout(1000);
        
        // Procura pela op√ß√£o do perfil configurado
        const perfilOptions = [
          page.getByRole('option', { name: new RegExp(perfil, 'i') }),
          page.locator(`mat-option:has-text("${perfil}")`),
          page.locator(`[role="option"]:has-text("${perfil}")`),
          page.locator('mat-option').filter({ hasText: new RegExp(perfil, 'i') })
        ];
        
        for (const perfilOption of perfilOptions) {
          if (await perfilOption.count() > 0) {
            console.log(`‚úÖ Selecionando papel "${perfil}"...`);
            await perfilOption.first().click();
            papelSelected = true;
            break;
          }
        }
        
        if (papelSelected) break;
        
        // Debug: listar op√ß√µes dispon√≠veis
        console.log('üîç Debug: Listando op√ß√µes de papel dispon√≠veis...');
        const allOptions = await page.locator('mat-option, [role="option"]').all();
        for (let j = 0; j < Math.min(allOptions.length, 20); j++) {
          const option = allOptions[j];
          const text = await option.textContent();
          console.log(`Op√ß√£o ${j + 1}: "${text}"`);
        }
        
        // Clica em ESC para fechar o dropdown se n√£o encontrou
        await page.keyboard.press('Escape');
        
      } catch (e) {
        console.log(`Erro ao tentar papel candidato ${i + 1}:`, e);
      }
    }
  }

  if (!papelSelected) {
    console.log(`‚ö†Ô∏è Campo de papel n√£o encontrado ou papel "${perfil}" n√£o dispon√≠vel`);
  }

  // Salvar (no modal)
  console.log('üíæ Procurando bot√£o salvar...');
  await page.waitForTimeout(2000);
  
  const salvarCandidates = [
    page.getByRole('button', { name: /gravar/i }),
    page.getByRole('button', { name: /salvar/i }),
    page.locator('button:has-text("Gravar")'),
    page.locator('button:has-text("Salvar")'),
    page.locator('button[type="submit"]'),
    page.locator('.mat-raised-button:has-text("Gravar")'),
    page.locator('.mat-button:has-text("Gravar")'),
    page.locator('mat-dialog-actions button:has-text("Gravar")'),
    page.locator('[mat-dialog-actions] button:has-text("Gravar")')
  ];

  let saved = false;
  for (let i = 0; i < salvarCandidates.length; i++) {
    const salvarBtn = salvarCandidates[i];
    if (await salvarBtn.count() > 0) {
      try {
        await salvarBtn.first().waitFor({ state: 'visible', timeout: 5000 });
        console.log(`üíæ Clicando no bot√£o salvar (candidato ${i + 1})...`);
        
        // Tenta clique normal primeiro
        try {
          await salvarBtn.first().click({ timeout: 3000 });
        } catch {
          // Se falhar, usa force click
          console.log('üíæ Tentando force click no bot√£o salvar...');
          await salvarBtn.first().click({ force: true });
        }
        
        saved = true;
        break;
      } catch (e) {
        console.log(`Erro ao tentar bot√£o salvar candidato ${i + 1}:`, e);
      }
    }
  }

  if (!saved) {
    // Debug: listar bot√µes dispon√≠veis
    console.log('üîç Debug: Listando bot√µes dispon√≠veis no modal...');
    const allButtons = await page.locator('button').all();
    for (let j = 0; j < Math.min(allButtons.length, 20); j++) {
      const button = allButtons[j];
      const text = await button.textContent();
      const isVisible = await button.isVisible();
      console.log(`Bot√£o ${j + 1}: "${text}" (vis√≠vel: ${isVisible})`);
    }
    throw new Error('Bot√£o salvar n√£o foi encontrado no modal');
  }

  // Aguarda um pouco para o salvamento processar
  await page.waitForTimeout(3000);
  
  console.log('‚úÖ √ìrg√£o Julgador e papel selecionados e salvos!');
}

/** Verifica se OJ j√° est√° na grade/lista de Localiza√ß√£o/Visibilidade */
export async function ojAlreadyAssigned(page: Page, ojName: string) {
  try {
    // Gerar varia√ß√µes do nome para busca mais abrangente
    const nameVariations = expandAbbreviations(ojName);
    console.log(`üîç Verificando se j√° est√° cadastrado - Varia√ß√µes: ${nameVariations.join(', ')}`);
    
    // Verificar cada varia√ß√£o do nome
    for (const variation of nameVariations) {
      const escapedName = variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // M√∫ltiplas estrat√©gias de busca para maior precis√£o
      const searchStrategies = [
        page.getByRole('row', { name: new RegExp(escapedName, 'i') }),
        page.locator(`tr:has-text("${variation}")`),
        page.locator(`tbody tr`).filter({ hasText: new RegExp(escapedName, 'i') }),
        page.locator(`[role="row"]:has-text("${variation}")`)
      ];
      
      // Verifica rapidamente se alguma estrat√©gia encontra o OJ
      for (const strategy of searchStrategies) {
        const count = await strategy.count();
        if (count > 0) {
          console.log(`‚úÖ √ìrg√£o j√° cadastrado encontrado como: ${variation}`);
          return true;
        }
      }
    }
    
    return false;
  } catch (error) {
    // Em caso de erro, assume que n√£o est√° cadastrado para continuar o processo
    console.log(`‚ö†Ô∏è Erro ao verificar se ${ojName} j√° est√° cadastrado:`, error);
    return false;
  }
}

/** Verifica se OJ com perfil espec√≠fico j√° est√° cadastrado */
export async function ojWithProfileAlreadyAssigned(page: Page, ojName: string, perfil: string) {
  try {
    // Gerar varia√ß√µes do nome para busca mais abrangente
    const nameVariations = expandAbbreviations(ojName);
    console.log(`üîç Verificando se ${perfil} j√° est√° cadastrado em ${ojName} - Varia√ß√µes: ${nameVariations.join(', ')}`);
    
    // Aguardar um pouco para garantir que a p√°gina carregou completamente
    await page.waitForTimeout(1000);
    
    // Verificar cada varia√ß√£o do nome
    for (const variation of nameVariations) {
      const escapedName = variation.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const escapedPerfil = perfil.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // M√∫ltiplas estrat√©gias de busca para encontrar linha com √≥rg√£o E perfil
      const searchStrategies = [
        // Estrat√©gia 1: Busca direta por texto
        page.locator(`tr:has-text("${variation}"):has-text("${perfil}")`),
        // Estrat√©gia 2: Busca por regex em tbody
        page.locator(`tbody tr`).filter({ hasText: new RegExp(escapedName, 'i') }).filter({ hasText: new RegExp(escapedPerfil, 'i') }),
        // Estrat√©gia 3: Busca por role="row"
        page.locator(`[role="row"]:has-text("${variation}"):has-text("${perfil}")`),
        // Estrat√©gia 4: Busca por aria-label
        page.locator(`[aria-label*="${variation}"][aria-label*="${perfil}"]`),
        // Estrat√©gia 5: Busca mais gen√©rica
        page.locator(`*:has-text("${variation}"):has-text("${perfil}")`),
        // Estrat√©gia 6: Busca por c√©lulas espec√≠ficas
        page.locator(`td:has-text("${variation}")`).locator(`..`).filter({ hasText: new RegExp(escapedPerfil, 'i') }),
        // Estrat√©gia 7: Busca por qualquer elemento que contenha ambos
        page.locator(`*`).filter({ hasText: new RegExp(escapedName, 'i') }).filter({ hasText: new RegExp(escapedPerfil, 'i') })
      ];
      
      // Verifica se alguma estrat√©gia encontra o OJ com o perfil espec√≠fico
      for (let i = 0; i < searchStrategies.length; i++) {
        const strategy = searchStrategies[i];
        try {
          const count = await strategy.count();
          if (count > 0) {
            console.log(`‚úÖ Perfil "${perfil}" j√° cadastrado em "${variation}" (estrat√©gia ${i + 1})`);
            
            // Debug: mostrar o texto encontrado
            const firstMatch = await strategy.first();
            const text = await firstMatch.textContent();
            console.log(`üìù Texto encontrado: "${text?.trim()}"`);
            
            return true;
          }
        } catch (strategyError) {
          console.log(`‚ö†Ô∏è Erro na estrat√©gia ${i + 1}:`, strategyError);
          continue;
        }
      }
    }
    
    console.log(`‚ùå Perfil "${perfil}" n√£o encontrado em "${ojName}"`);
    
    // Debug: capturar estrutura da p√°gina para an√°lise
    try {
      console.log(`üîç DEBUG: Analisando estrutura da p√°gina...`);
      
      // Capturar todas as linhas da tabela
      const allRows = await page.locator('tr, [role="row"]').all();
      console.log(`üìä Total de linhas encontradas: ${allRows.length}`);
      
      // Mostrar primeiras 10 linhas para debug
      for (let i = 0; i < Math.min(allRows.length, 10); i++) {
        const row = allRows[i];
        const text = await row.textContent();
        const isVisible = await row.isVisible();
        console.log(`Linha ${i + 1} (vis√≠vel: ${isVisible}): "${text?.trim()}"`);
      }
      
      // Verificar se h√° elementos com o nome do √≥rg√£o
      const orgaoElements = await page.locator(`*:has-text("${ojName}")`).all();
      console.log(`üîç Elementos com "${ojName}": ${orgaoElements.length}`);
      
      // Verificar se h√° elementos com o nome do perfil
      const perfilElements = await page.locator(`*:has-text("${perfil}")`).all();
      console.log(`üîç Elementos com "${perfil}": ${perfilElements.length}`);
      
    } catch (debugError) {
      console.log(`‚ö†Ô∏è Erro no debug:`, debugError);
    }
    
    return false;
  } catch (error) {
    // Em caso de erro, assume que n√£o est√° cadastrado para continuar o processo
    console.log(`‚ö†Ô∏è Erro ao verificar se ${perfil} j√° est√° cadastrado em ${ojName}:`, error);
    return false;
  }
}
